#!/bin/bash
# bmu v1 created 13 October 2022 
# By Joel Savitz <jsavitz@redhat.com>
#
# Purpose: beakermeup II

## set up beaker machine

# Configuration defaults
# These variables are sourced from $BWD/config on startup and
# written back the file before connecting to the host

# The username used when connecting to a host.
USER="root"

# Version of bmu used to generate config.
# (not really used functionally)
VERSION="2.0"

# Set this to any string to enable debug output.
# Set to empty to disable debug output.
DEBUG=""

# The working directory for the script.
# The script attempts to create the directory if it is not found.
BWD="${HOME}/.beakermeup"

# The names of groups of scripts to be run by 'go' during configuration
# of a remote host. Each item in the space-separated list of strings
# refers to a bash function called install_$item_target() that assumes
# $HOST refers to an online remote that we can ssh into as $USER. The
# scripts are run locally and expected to use ssh and wrapper scripts
# to ensure their targets are run on the remote host
INSTALL_TARGETS="kerneldeps gitconfig user scripts vim"

# The last host the script connected to. Initally empty, but useful for
# quickly connecting to the previous host, e.g usage: `bmu go last`
LAST_HOST=""

# This editor is invoked to edit text files when the script calls for it,
# e.g:`bmu host edit HOSTNAME`.
EDITOR="vim"

# This string is set as the password for the user account created on a
# configured remote named by the output of `whoami`. Yeah it's a
# plaintext password don't worry about it. It's not supposed to be secure.
# honestly you should just not use the user target on an insecure machine.
# But really, you shouldn't be using insecure networks at all, and so I
# recommend this script only be run within the assumption of a secure network
# and private DNS, for those are the assumptions under which this script was
# written.
TESTPASSWD="f"

# Other variables that are _not_ config values

# These are set to empty in case the were not empty
# in the calling bash environment. They are used internally.
HOST=""
COMM=""
SUBCOMM=""
KEY=""
VALUE=""
ARG1=""
ARG2=""
ARG3=""

usage() {
	cat <<EOF
usage: `basename ${0}` [-h | -f] <command> <arguments...>
	-h: show this message
	-f: continue when connection check fails
	commands:
		go: connect to and/or configure a remote host
		console: connect to the console of a host
		ping: test remote connectivity and get info
		host: manage known remote hosts
		subcommands:
			list: list known remote hosts
			delete: delete local knowledge of a remote host
			edit: edit a local host config with \$EDITOR
		config: set a config key (\$2) to a value (\$3)
		help: command help
	
	use '`basename ${0}` help [COMMAND]' for more help
EOF
}

# Wrapper for printf: set DEBUG to non-empty to enable
D() {
	if [ ! -z "${DEBUG}" ]; then
		printf "[DEBUG][\n${*}]\n"
	fi
}



# $1: script to run on $HOST
run_on_remote() {
	if ssh ${USER}@${HOST} "${1}"; then
		D "ran:\n${1}\nsuccessfully on ${USER}@${HOST}\n"
		return 0
	else
		echo "failed to run on ${USER}@${HOST}"
		D "failed script:\n${1}\nend failed script.\n"
		return 1
	fi
}

# $1: condition to evaluate on $HOST
# $2: run on $HOST when condition is true
run_on_remote_if_true() {
	if [ -z "${1}" ]; then
		echo "run_on_remote_if_true: binary condition required"
		return 1
	else
		CONDITION="${1}"
	fi

	if [ -z "${2}" ]; then
		# no-op
		SCRIPT=":"
	else
		SCRIPT="${2}"
	fi

	run_on_remote "if ${CONDITION} ; then
		${SCRIPT};
	fi"
}

# $1: condition to evaluate on $HOST
# $2: run on $HOST when condition is false
# must escape " characters in both arguments
run_on_remote_if_false() {
	run_on_remote_if_true "! $1 " "${2}"
}

# $1: file to copy to remote
# $2: (optional) destination directory (defaults to ~)
copy_to_remote() {
	if [ -z ${1} ]; then
		echo "error: filename required"
		return 1
	fi
	FILE=${1}

	DEST=${2:-"~"}
	if scp ${FILE} ${USER}@${HOST}:${DEST}; then
		D "copy ${FILE} to ${DEST} on ${USER}@${HOST}\n"
		return 0
	else
		echo "failed to copy ${FILE} to ${DEST} on ${USER}@${HOST}\n"
		return 1
	fi

}

# $1: path to file on remote
# $2: destination
copy_from_remote() {
	if [ -z ${1} ]; then
		echo "error: filename required"
		return 1
	fi
	FILE=${1}

	if [ -z ${2} ]; then
		echo "error: destination required"
		return 1
	fi
	DEST=${2}

	if scp ${USER}@${HOST}:${FILE} ${DEST}; then
		D "copy ${FILE} to ${DEST} from ${USER}@${HOST}\n"
		return 0
	else
		echo "failed to copy ${FILE} from ${DEST} on ${USER}@${HOST}\n"
		return 1
	fi
}

hello_there() {
	printf "Hello there, user. I am  `basename $0` v%s\n" ${VERSION}
	printf "Working directory: ${BWD}\n"
	printf "Command line: ${*}\n"
	COMM=${1}
	D "Command: ${COMM}\n"
}

# write config config file
write_config() {
	cat <<EOF |
USER="${USER}"
VERSION="${VERSION}"
BWD="${BWD}"
DEBUG="${DEBUG}"
INSTALL_TARGETS="${INSTALL_TARGETS}"
LAST_HOST="${LAST_HOST}"
TESTPASSWD="${TESTPASSWD}"
EOF
	cat > ${BWD}/config
	D "wrote config file in ${BWD}/config\n"
}

# load saved config values
read_config() {
	source "${BWD}/config"
	D "load config from ${BWD}/config:\n$(cat "${BWD}/config")\n"
}

# default configuration values for a host
HOST_LASTSEEN=""
HOST_HAS_KERNELDEPS="no"
HOST_HAS_GITCONFIG="no"
HOST_HAS_USER="no"
HOST_HAS_SCRIPTS="no"
HOST_HAS_VIM="no"

write_config_host() {
	cat <<EOF |
HOST_LASTSEEN="${HOST_LASTSEEN}"
HOST_HAS_KERNELDEPS="${HOST_HAS_KERNELDEPS}"
HOST_HAS_GITCONFIG="${HOST_HAS_GITCONFIG}"
HOST_HAS_USER="${HOST_HAS_USER}"
HOST_HAS_SCRIPTS="${HOST_HAS_SCRIPTS}"
HOST_HAS_VIM="${HOST_HAS_VIM}"
EOF
	cat > "${BWD}/${HOST}.bmu"
	D "wrote config file to ${BWD}/${HOST}.bmu"
	copy_to_remote "${BWD}/${HOST}.bmu"
}

read_config_host() {
	# if we don't have an entry for this host, overwrite remote config
	if [ ! -f "${BWD}/${HOST}.bmu" ]; then
		D "local config not found. create and copy to host\n"
		write_config_host
		copy_to_remote ${BWD}/${HOST}.bmu
	fi


	source "${BWD}/${HOST}.bmu"
}

# get a yes or no from the user
# $1: prompt
ask_binary() {
	if [ -z "${1}" ]; then
		echo "prompt required"
	fi
	PROMPT=${1}
	while true; do
		read -p "${PROMPT}" answer
		case "$answer" in
			[Yy]*) return 0;;
			[Nn]*) return 1;;
			*) echo "Please answer yes or no";;
		esac
	done
}
setup() {

	if [ ! -d ${BWD} ]; then
		echo "${BWD} not found. creating..."
		if mkdir ${BWD}; then
			echo "created ${BWD}"
		else
			echo "failed to create ${BWD}"
			return 1
		fi
	else
		D "found working directory ${BWD}\n"
		read_config
	fi

	if [ ! -w ${BWD} ]; then
		echo "${BWD} not writable"
		return 1
	fi

	write_config
}

host_ssh_verify() {
	if ssh -o ConnectTimeout=5 "${USER}@${HOST}" "echo" &>"${BWD}/${HOST}.verify"; then
		D "verified connection to ${USER}@${HOST}\n"
		return 0
	elif cat "${BWD}/${HOST}.verify" | grep "@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @" >/dev/null; then
		echo "Remote host key is different than local key"
		if ask_binary "Remove local key and reconnect? "; then
			# NOTE: should this be constant?
			sed -i "/${HOST}/d" ~/.ssh/known_hosts
			host_ssh_verify
			return $?
		else
			echo "quitting..."
			return 1
		fi
	else
		echo "failed to connect to ${USER}@${HOST}"
		if [ ! -z $ignore_failed_connection ]; then
			return 0
		else
			return 1
		fi
	fi
}

usage_ping() {
	cat <<EOF
usage: `basename ${0}` ping HOSTNAME
	Connect to HOSTNAME and check
	basic information about a machine.
EOF
}

# from CLI:
# $2: remote hostname
# $3: set to non-empty for quiet mode
run_ping() {
	_prepare_to_connect || return 1

	run_on_remote "uname -nvr;uptime --pretty"
	test ! -z "${2}" &&echo "Host online."
}

usage_go() {
	cat <<EOF
usage: `basename ${0}` go HOSTNAME
	Connect to HOSTNAME. Ensure that
	the remote machine is configured to
	build the upstream Linux kernel.
EOF
}

DEPS="git gcc gcc-c++ make vim cmake  python3-devel ncurses-devel flex bison openssl-devel elfutils-libelf-devel  bc cscope libudev-devel wget openssl tar dwarves"

install_kerneldeps_target() {
	run_on_remote "dnf install -y ${DEPS}"
}

install_gitconfig_target() {
	local git_name="$(git config --get user.name)"
	local git_email="$(git config --get user.email)"

	run_on_remote "git config --global user.name ${git_name};
		git config --global user.email ${git_email}"
}

install_user_target() {

	local newuser=`whoami`

	run_on_remote_if_false "id ${newuser}" "useradd ${newuser}"
	run_on_remote_if_false "cat /etc/group | grep ^sudo" "groupadd sudo"
	run_on_remote 'echo "%sudo	ALL=(ALL)	NOPASSWD: ALL" | sudo EDITOR="tee -a" visudo'
	run_on_remote "usermod -G sudo ${newuser}"
	run_on_remote "echo ${TESTPASSWD} | passwd ${newuser} --stdin"
	run_on_remote_if_false "test ! -f ~/.ssh/id_rsa" 'ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -P ""'
}

bash_scripts_url="https://gitlab.cee.redhat.com/jsavitz/bash-scripts"
install_scripts_target() {
	local repo_name="${bash_scripts_url/"https://gitlab.cee.redhat.com/jsavitz/"}"

	run_on_remote_if_true "test ! -d ${repo_name} &&
		git -c http.sslVerify=false clone ${bash_scripts_url}.git" \
		"bash ${repo_name}/install.sh"
}

vim_scripts_url="https://github.com/theyoyojo/vim-portability-suite"

install_vim_target() {
	local repo_name="${vim_scripts_url/"https://github.com/theyoyojo/"}"

	run_on_remote_if_true "test ! -d ${repo_name} &&
		git clone ${vim_scripts_url}" \
		"bash ${repo_name}/install.sh"
}

# print a string repetitively with a delay
# $1: the string 	(defaults to '.')
# $2: the delay		(defaults to 0.1s [seconds])
# #3: the repetitions	(defauts to 10)
# $3: the prefix	(defaults to empty)
# $4: the suffix	(defaults to newline)
animate_single_string() {
	if [ -z "${1}" ]; then
		string='.'
	else
		string="${1}"
	fi

	if [ -z "${2}" ]; then
		delay='0.1'
	else
		delay="${2}"
	fi

	if [ -z "${3}" ]; then
		repetitions=10
	else
		repetitions="${3}"
	fi

	if [ -z "${4}" ]; then
		prefix=''
	else
		prefix="${4}"
	fi

	if [ -z "${5}" ]; then
		suffix=`printf '\n'`
	else
		suffix="${5}"
	fi

	printf '%s' "${prefix}"

	for ((i=0; i<${repetitions};++i)); do
		sleep "${delay}"
		printf '%s' "${string}"
	done

	printf '%s' "${suffix}"

}

connect_loop() {
	LAST_HOST="${HOST}"
	write_config

	while true; do
		printf "connecting to ${USER}@${HOST}"
		animate_single_string
		if ssh -o ConnectTimeout=5 "${USER}@${HOST}"; then
			D "disconnected: return of zero\n"
		else
			D "disconnected: return $?\n"
		fi
		reset
		printf "disconnected. restarting"
		animate_single_string
		echo
		
	done
}


# from CLI:
# $2: remote hostname
run_go() {
	if [ "${HOST}" == "last" ]; then
		echo "using last remote host: ${LAST_HOST}"
		HOST="${LAST_HOST}"
	fi

	_prepare_to_connect || return 1

	read_config_host

	HOST_LASTSEEN="`date`"

	for target in ${INSTALL_TARGETS}; do
		local config="HOST_HAS_${target^^}"
		value=$(eval echo "\$${config}" | cat)
		if [ "${value}" == "no" ]; then
			D "Start install target $target\n"
			if install_${target}_target; then
				# write "yes" to HOST_HAS_$target on success
				printf -v ${config} "yes" > /dev/null
			else
				echo "failed to reach install target $target"
			fi 
		fi
	done

	write_config_host

	connect_loop
}

usage_config() {
	cat <<EOF
usage: `basename ${0}` config KEY VALUE
	Set the variable KEY to VALUE.
	This will be saved to the config
	file if the key is used.
EOF
}

# from CLI
# $2: config key to set
# $3: value to to set key to, leave empty to set to empty
run_config() {
	read_config

	if [ -z ${KEY} ]; then
		echo "key required but found empty"
	fi

	
	eval "${KEY}=${VALUE}"
	D "set: ${KEY}=${VALUE}\n"

	write_config
}

usage_edit() {
	cat <<EOF
usage: `basename ${0}` edit HOSTNAME
	Edit HOSTNAME config with \$EDITOR if
	the file exists.
EOF
}

run_edit() {
	if ! dereference_hostref; then
		echo "unable to dereference hostref"
		return 1
	fi

	$EDITOR "${BWD}/${HOST}.bmu"
}

usage_delete() {
	cat <<EOF
usage: `basename ${0}` delete HOSTNAME
	Delete local knowledge on remote HOSTNAME.
EOF
}

run_delete() {
	if [ -z "${HOST}" ]; then
		echo "hostname is required"
		return 1
	fi

	if [ ! -f "${BWD}/${HOST}.bmu" ]; then
		echo "host '${HOST}' not found"
		return 1
	fi

	if ask_binary "Are you sure you want to delete '${BWD}/${HOST}.bmu'? "; then
		rm "${BWD}/${HOST}.bmu"
		echo "deleted ${BWD}/${HOST}.bmu"
	else
		echo "operation aborted"
	fi
}

usage_console() {
	cat <<EOF
usage: `basename ${0}` console HOST
	Connect to the console of HOST.
EOF
}

run_console() {
	while true; do
		printf "connecting to console for ${HOST}"
		animate_single_string
		if console -M "console.eng.bos.redhat.com" "${HOST}"; then
			D "disconnected: return of zero\n"
		else
			D "disconnected: return $?\n"
		fi
		reset
		printf "disconnected. restarting"
		animate_single_string
		echo
		
	done
}

usage_list() {
	cat <<EOF
usage: `basename ${0}` list [ OPTIONS ]
	List known remotes.
	Pass yes as an option for machine-readable output.
EOF
}

# returns truth of whether ${1} is the last connected host
host_is_last() {
	test "${1}" = "${LAST_HOST}"
}

# moved from loop below for readability
nicefmt='[remote %s]:\n\thost: %s\n\t%slast seen: %s\n\n'

# list known remotes
# $1: set to yes to to enable machine readable format
run_list() {
	i=0
	for remotefile in $(cd ${BWD} && ls *.bmu); do
		remote="${remotefile/.bmu}"
		(
			islast=
			if [ "${OPTIONS}" = "yes" ]; then
				fmt='%s,%s,%s,%s\n'
				if host_is_last "${remote}"; then
					islast="yes"
				else
					islast="no"
				fi
			else
				fmt="$nicefmt"
				if host_is_last "${remote}"; then
					islast=`printf '[LAST USED]\n\t'`
				else
					islast=""
				fi
			fi
			source "${BWD}/${remotefile}"
			# index host lastconnected lastseen
			printf  "${fmt}" \
				"${i}" "${remote}" "${islast}" "${HOST_LASTSEEN}"
		)
		i=$(echo "${i}+1" | bc)
	done
}

usage_help() {
	cat <<EOF
usage: `basename ${0}` help TOPIC
	Get information on TOPIC
EOF
}

run_help() {
	if ! command -v usage_${TOPIC}; then
		echo "unknown help topic: '${TOPIC}'"
		return 1
	fi

	usage_${TOPIC}
}

# The hostref to reference is assumed to be in $HOST.
# If $HOST is a HOSTREF:
# 	Upon termination, $HOST will be set to the hostname
#	referenced by the HOSTREF initially in $HOST
# Else:
#	This function does not modify $HOST
# FAQ:
#	Q: What is a HOSTREF?
# 	A: A HOSTREF is a reference to a hostname that takes
#	   the form of either a number prefixed by '@', or
#	   a string previously defined to be an alias of
#	   a hostname. Or, to put it another way:
#		HOSTREF := @[0-9]+ | [a-zA-Z_]?[a-zA-Z0-9_]+
#	Q: What do the numbered HOSTREFs with the '@' prefixes
#	   refer to?
#	A: A HOSTREF of the form '@[0-9]+' refers to the an index
#          for a host that can be found with `bmu list`. The
#	   indices start from 0. Some syntactically valid
#	   HOSTREFs of this type are beyond the highest index in
#	   the list, and using them will produce an error.
#	Q: Are there any aliases predefined of built-in?
#	A: Right now the only built-in is 'last', which refers to
#	   the most recently used host. I plan to add some more if
#	   I think of useful ones.
#	Q: How can I define my own aliases?
#	A: I haven't implemented this feature yet. It is a TODO.
#	Q: Does this function assume that $HOST is set to something valid?
#	A: Yes.
dereference_hostref() {
	old=${HOST}
	# Test if $HOST contains an index reference
	if [[ "${HOST}" =~ ^\@[[:digit:]]+$ ]]; then
		index=${HOST/@}
		D "index reference: $index"
		OPTIONS="yes"
		HOST=`run_list |
			awk -v idx="${index}" \
			'BEGIN 		{ FS="," }
			 $1 ~ idx	{ print $2 }'`
		if [ -z "${HOST}" ]; then
			echo "index ${index} is out of bounds"
			return 1
		fi
	fi

	if [ "${HOST}" == "last" ]; then
		echo "using last remote host: ${LAST_HOST}"
		HOST="${LAST_HOST}"
	fi
	# TODO: custom alias dereference

	printf "HOSTREF '%s' resolved to '%s'\n" "${old}" "${HOST}"
}

# assumes $HOST is set to the target remote or remote reference
_prepare_to_connect() {
	if [ -z "${HOST}" ]; then
		echo "prepare_to_connect: hostname is required"
		return 1
	fi

	if ! dereference_hostref; then
		echo "failed to dereference HOSTREF ${HOST}"
		return 1
	fi

	if ! host_ssh_verify;then
		echo "prepare_to_conect: unable to connnect to host \"${HOST}\""
		return 1
	fi
}

usage_host() {
	cat <<EOF
usage: `basename ${0}` host SUBCOMMAND ARGUMENTS...
	A set of functions to manage known remote hosts.
	subcommands:
		list OPTIONS
			List locally known hosts.
			Pass "yes" as an option to display relatively
			machine-readable output (comma separated values).
		edit HOST
			edit the config HOST if it exists
		delete HOST
			delete local knowledge of a remote host
EOF
}

run_host() {
	case "${SUBCOMM}" in
		"list")
			OPTIONS=${ARG3}
			;;
		"delete")
			HOST=${ARG3}
			;;
		"edit")
			HOST=${ARG3}
			;;
		*)
			echo "unknown subcommand ${SUBCOMM}"
			return 1
			;;
	esac

	run_${SUBCOMM}	
}

usage_test() {
	cat <<EOF
usage: `basename ${0}` test ARGUMENTS...
	Random tests.
EOF
}

# $1,$2,$3 => ARG1, ARG2, ARG3
run_test() {
	HOST=${ARG2}
	# _prepare_to_connect || return 1

	# FOO="[ ! -z \"foo\" ]"
	
	# run_on_remote "if ${FOO} ; then
	# 	echo \"true\";
	# else
	# 	echo \"false\";
	# fi"

	dereference_hostref
	echo "\$HOST after dereference: ${HOST}"
}

# $1: command to run
# $2: hostname
run() {
	if [ -z ${1} ]; then
		usage
		return 1
	fi

	D "${COMM} selected\n"
	case "${COMM}" in
		"config")
			KEY=${2}
			VALUE=${3}
			;;
		"ping")
			HOST=${2}
			;;
		"console")
			HOST=${2}
			;;
		"go")
			HOST=${2}
			;;
		"host")
			SUBCOMM=${2}
			ARG3=${3}
			;;
		"help")
			TOPIC=${2}
			;;
		"test")
			ARG1=${1}
			ARG2=${2}
			ARG3=${3}
			;;
		*)
			echo "unknown command ${COMM}"
			return 1
			;;
	esac

	run_${COMM}
}

ignore_failed_connection=
while getopts "hf" OPTION; do
	case "${OPTION}" in
		h)
			usage
			exit 0
			;;
		f)
			# ignore invalid host check
			ignore_failed_connection=yes
			;;

		*)
			echo "unknown option ${OPTION}"
			usage
			exit 0
			;;
	esac
done
shift $((OPTIND - 1))

hello_there $*

if setup; then
	run ${*}
	exit ${?}
else
	echo "setup failed"
	exit 1
fi
